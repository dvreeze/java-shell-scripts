#!/usr/bin/env -S java --source 21

/*
 * Copyright 2025-2025 Chris de Vreeze
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.PrintWriter;
import java.io.StringWriter;
import java.math.BigDecimal;
import java.net.InetAddress;
import java.net.InterfaceAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.util.*;

/**
 * Java program and shell script showing all network interfaces as JSON.
 *
 * @author Chris de Vreeze
 */
public final class ShowInterfacesAsJson implements Runnable {

    public static void main(String... args) {
        ShowInterfacesAsJson runnable = new ShowInterfacesAsJson(args);
        runnable.run();
    }

    private final List<String> args;

    public ShowInterfacesAsJson(String[] args) {
        this.args = Arrays.stream(args).toList();
    }

    @Override
    public void run() {
        Objects.requireNonNull(args); // Dummy statement to please the compiler

        if (Runtime.version().feature() < 21) {
            throw new IllegalStateException("Java version >= 21 required");
        }

        // Running on Linux, the newline is the single-char Unix newline character
        // So method println always outputs a Linux newline
        // Consider using "unix2dos" on the output of the program for files that should have a "Windows newline"

        PrintWriter stdOutWriter = new PrintWriter(System.out, true);
        PrintWriter stdErrWriter = new PrintWriter(System.err, true);

        try {
            List<NetworkInterface> networkInterfaces = NetworkInterface.networkInterfaces().toList();
            stdOutWriter.println(
                    JsonSupport.JsonArray.from(
                            networkInterfaces
                                    .stream()
                                    .map(v -> (JsonSupport.JsonValue) convertToJson(v))
                                    .toList()
                    )
            );
        } catch (SocketException | RuntimeException e) {
            stdErrWriter.println("Exception thrown: " + e);
        }
    }

    private JsonSupport.JsonObject convertToJson(NetworkInterface networkInterface) {
        try {
            return JsonSupport.JsonObject.from(
                    List.of(
                            Map.entry("index", JsonSupport.JsonNumber.from(networkInterface.getIndex())),
                            Map.entry("name", new JsonSupport.JsonString(networkInterface.getName())),
                            Map.entry(
                                    "displayName",
                                    Optional.ofNullable(networkInterface.getDisplayName())
                                            .map(v -> (JsonSupport.JsonValue) new JsonSupport.JsonString(v))
                                            .orElse(JsonSupport.JsonNull.INSTANCE)
                            ),
                            Map.entry("hardwareAddress", extractHardwareAddressAsJson(networkInterface)),
                            Map.entry("mtu", JsonSupport.JsonNumber.from(networkInterface.getMTU())),
                            Map.entry("isLoopback", new JsonSupport.JsonBoolean(networkInterface.isLoopback())),
                            Map.entry("isPointToPoint", new JsonSupport.JsonBoolean(networkInterface.isPointToPoint())),
                            Map.entry("isUp", new JsonSupport.JsonBoolean(networkInterface.isUp())),
                            Map.entry("isVirtual", new JsonSupport.JsonBoolean(networkInterface.isVirtual())),
                            Map.entry("supportsMulticast", new JsonSupport.JsonBoolean(networkInterface.supportsMulticast())),
                            Map.entry(
                                    "interfaceAddresses",
                                    JsonSupport.JsonArray.from(
                                            networkInterface
                                                    .getInterfaceAddresses()
                                                    .stream()
                                                    .map(this::convertToJson)
                                                    .toList()
                                    )
                            ),
                            Map.entry(
                                    "parent",
                                    Optional.ofNullable(networkInterface.getParent())
                                            .map(v -> (JsonSupport.JsonValue) new JsonSupport.JsonString(v.getName()))
                                            .orElse(JsonSupport.JsonNull.INSTANCE)
                            ),
                            Map.entry(
                                    "subInterfaces",
                                    JsonSupport.JsonArray.from(
                                            networkInterface
                                                    .subInterfaces()
                                                    .map(v -> (JsonSupport.JsonValue) new JsonSupport.JsonString(v.getName()))
                                                    .toList()
                                    )
                            )
                    )
            );
        } catch (SocketException e) {
            throw new RuntimeException(e);
        }
    }

    private JsonSupport.JsonValue extractHardwareAddressAsJson(NetworkInterface networkInterface) {
        try {
            byte[] hardwareAddress = networkInterface.getHardwareAddress();

            return Optional.ofNullable(hardwareAddress)
                    .map(v ->
                            (JsonSupport.JsonValue) new JsonSupport.JsonString(
                                    convertHardwareAddressToString(v)
                            )
                    )
                    .orElse(JsonSupport.JsonNull.INSTANCE);
        } catch (SocketException e) {
            throw new RuntimeException(e);
        }
    }

    private String convertHardwareAddressToString(byte[] hardwareAddress) {
        // See https://www.baeldung.com/java-mac-address

        String[] hexadecimal = new String[hardwareAddress.length];
        for (int i = 0; i < hardwareAddress.length; i++) {
            hexadecimal[i] = String.format("%02X", hardwareAddress[i]);
        }
        return String.join("-", hexadecimal);
    }

    private JsonSupport.JsonValue convertToJson(InterfaceAddress interfaceAddress) {
        return JsonSupport.JsonObject.from(
                List.of(
                        Map.entry("networkPrefixLength", JsonSupport.JsonNumber.from(interfaceAddress.getNetworkPrefixLength())),
                        Map.entry(
                                "address",
                                Optional.ofNullable(interfaceAddress.getAddress())
                                        .map(this::convertToJson)
                                        .orElse(JsonSupport.JsonNull.INSTANCE)
                        ),
                        Map.entry(
                                "broadcast",
                                Optional.ofNullable(interfaceAddress.getBroadcast())
                                        .map(this::convertToJson)
                                        .orElse(JsonSupport.JsonNull.INSTANCE)
                        )
                )
        );
    }

    private JsonSupport.JsonValue convertToJson(InetAddress inetAddress) {
        return JsonSupport.JsonObject.from(
                List.of(
                        Map.entry(
                                "hostAddress",
                                Optional.ofNullable(inetAddress.getHostAddress())
                                        .map(v -> (JsonSupport.JsonValue) new JsonSupport.JsonString(v))
                                        .orElse(JsonSupport.JsonNull.INSTANCE)
                        ),
                        Map.entry(
                                "hostName",
                                Optional.ofNullable(inetAddress.getHostName())
                                        .map(v -> (JsonSupport.JsonValue) new JsonSupport.JsonString(v))
                                        .orElse(JsonSupport.JsonNull.INSTANCE)
                        ),
                        Map.entry(
                                "canonicalHostName",
                                Optional.ofNullable(inetAddress.getCanonicalHostName())
                                        .map(v -> (JsonSupport.JsonValue) new JsonSupport.JsonString(v))
                                        .orElse(JsonSupport.JsonNull.INSTANCE)
                        ),
                        Map.entry("isAnyLocalAddress", new JsonSupport.JsonBoolean(inetAddress.isAnyLocalAddress())),
                        Map.entry("isLinkLocalAddress", new JsonSupport.JsonBoolean(inetAddress.isLinkLocalAddress())),
                        Map.entry("isSiteLocalAddress", new JsonSupport.JsonBoolean(inetAddress.isSiteLocalAddress())),
                        Map.entry("isLoopbackAddress", new JsonSupport.JsonBoolean(inetAddress.isLoopbackAddress())),
                        Map.entry("isMulticastAddress", new JsonSupport.JsonBoolean(inetAddress.isMulticastAddress())),
                        Map.entry("isMCGlobal", new JsonSupport.JsonBoolean(inetAddress.isMCGlobal())),
                        Map.entry("isMCLinkLocal", new JsonSupport.JsonBoolean(inetAddress.isMCLinkLocal())),
                        Map.entry("isMCNodeLocal", new JsonSupport.JsonBoolean(inetAddress.isMCNodeLocal())),
                        Map.entry("isMCOrgLocal", new JsonSupport.JsonBoolean(inetAddress.isMCOrgLocal())),
                        Map.entry("isMCSiteLocal", new JsonSupport.JsonBoolean(inetAddress.isMCSiteLocal()))
                )
        );
    }

    // JSON support (copied from other source file)

    /**
     * JSON support, to be copied (as static member class) into Java shell scripts that need it.
     *
     * @author Chris de Vreeze
     */
    public static class JsonSupport {

        private JsonSupport() {
        }

        // Very heavily inspired by JSON-B

        public enum JsonValueType {
            OBJECT, ARRAY, NUMBER, BOOLEAN, STRING, NULL
        }

        // Intended to be immutable data structures

        public interface JsonValue {

            JsonSupport.JsonValueType getValueType();

            // TODO Consider taking control over malformed/unmappable character mapping (using CharsetEncoder)

            void print(PrintWriter pw, String indentString);
        }

        public interface JsonStructure extends JsonSupport.JsonValue {
        }

        public record JsonObject(
                Map<String, JsonSupport.JsonValue> fields) implements JsonSupport.JsonStructure {

            public JsonObject {
                fields = new LinkedHashMap<>(fields);
            }

            @Override
            public JsonSupport.JsonValueType getValueType() {
                return JsonSupport.JsonValueType.OBJECT;
            }

            @Override
            public void print(PrintWriter pw, String indentString) {
                pw.println("{");

                String newIndentString = indentString + "    ";

                List<Map.Entry<String, JsonSupport.JsonValue>> entries = List.copyOf(fields.entrySet());

                if (!entries.isEmpty()) {
                    for (Map.Entry<String, JsonSupport.JsonValue> entry : entries.subList(0, entries.size() - 1)) {
                        pw.print(newIndentString);
                        pw.printf("\"%s\": ", entry.getKey());
                        entry.getValue().print(pw, newIndentString);
                        pw.println(",");
                    }
                    Map.Entry<String, JsonSupport.JsonValue> lastEntry = entries.getLast();
                    pw.print(newIndentString);
                    pw.printf("\"%s\": ", lastEntry.getKey());
                    lastEntry.getValue().print(pw, newIndentString);
                    pw.println();
                }

                pw.print(indentString);
                pw.print("}");
            }

            @Override
            public String toString() {
                StringWriter sw = new StringWriter();
                PrintWriter pw = new PrintWriter(sw);

                print(pw, "");
                return sw.toString();
            }

            public static JsonSupport.JsonObject from(List<Map.Entry<String, JsonSupport.JsonValue>> fields) {
                Map<String, JsonSupport.JsonValue> fieldMap = new LinkedHashMap<>();
                for (Map.Entry<String, JsonSupport.JsonValue> entry : fields) {
                    fieldMap.put(entry.getKey(), entry.getValue());
                }
                return new JsonSupport.JsonObject(fieldMap);
            }
        }

        public record JsonArray(
                List<JsonSupport.JsonValue> elements) implements JsonSupport.JsonStructure {

            public JsonArray {
                elements = List.copyOf(elements);
            }

            @Override
            public JsonSupport.JsonValueType getValueType() {
                return JsonSupport.JsonValueType.ARRAY;
            }

            @Override
            public void print(PrintWriter pw, String indentString) {
                pw.println("[");

                String newIndentString = indentString + "    ";

                if (!elements.isEmpty()) {
                    for (JsonSupport.JsonValue element : elements.subList(0, elements.size() - 1)) {
                        pw.print(newIndentString);
                        element.print(pw, newIndentString);
                        pw.println(",");
                    }
                    JsonSupport.JsonValue lastElement = elements.getLast();
                    pw.print(newIndentString);
                    lastElement.print(pw, newIndentString);
                    pw.println();
                }

                pw.print(indentString);
                pw.print("]");
            }

            @Override
            public String toString() {
                StringWriter sw = new StringWriter();
                PrintWriter pw = new PrintWriter(sw);

                print(pw, "");
                return sw.toString();
            }

            public static JsonSupport.JsonArray from(List<JsonSupport.JsonValue> elements) {
                return new JsonSupport.JsonArray(List.copyOf(elements));
            }
        }

        public interface JsonAtomicValue extends JsonSupport.JsonValue {
        }

        public record JsonNumber(BigDecimal value) implements JsonSupport.JsonAtomicValue {

            public JsonNumber {
                Objects.requireNonNull(value);
            }

            @Override
            public JsonSupport.JsonValueType getValueType() {
                return JsonSupport.JsonValueType.NUMBER;
            }

            @Override
            public void print(PrintWriter pw, String indentString) {
                pw.print(this);
            }

            @Override
            public String toString() {
                return String.format("%s", value().toString());
            }

            public static JsonSupport.JsonNumber from(int number) {
                return new JsonSupport.JsonNumber(new BigDecimal(number));
            }
        }

        public record JsonBoolean(boolean value) implements JsonSupport.JsonAtomicValue {

            @Override
            public JsonSupport.JsonValueType getValueType() {
                return JsonSupport.JsonValueType.BOOLEAN;
            }

            @Override
            public void print(PrintWriter pw, String indentString) {
                pw.print(this);
            }

            @Override
            public String toString() {
                return String.valueOf(value());
            }
        }

        public record JsonString(String value) implements JsonSupport.JsonAtomicValue {

            public JsonString {
                Objects.requireNonNull(value);
            }

            @Override
            public JsonSupport.JsonValueType getValueType() {
                return JsonSupport.JsonValueType.STRING;
            }

            @Override
            public void print(PrintWriter pw, String indentString) {
                pw.print(this);
            }

            @Override
            public String toString() {
                return String.format("""
                                "%s"\s""".stripTrailing(),
                        escapeDoubleQuotes(value())
                );
            }
        }

        public enum JsonNull implements JsonSupport.JsonValue {
            INSTANCE;

            @Override
            public JsonSupport.JsonValueType getValueType() {
                return JsonSupport.JsonValueType.NULL;
            }

            @Override
            public void print(PrintWriter pw, String indentString) {
                pw.print(this);
            }

            @Override
            public String toString() {
                return "null";
            }
        }

        // See https://docs.ycrash.io/ycrash-features/ycrash-faq/escaping-special-characters.html

        private static String escapeDoubleQuotes(String s) {
            return s.replace("\"", "\\\"");
        }
    }
}
